
# # Working with Custom Images
# 
# 
# 
# 
# The Kaggle Competition: [Cats and Dogs](https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition) includes 25,000 images of cats and dogs. We will be building a classifier that works with these images and attempt to detect dogs versus cats!
# 
# The pictures are numbered 0-12499 for both cats and dogs, thus we have 12,500 images of Dogs and 12,500 images of Cats. This is a huge dataset!!
# 

# In[1]:


import matplotlib.pyplot as plt
import cv2
get_ipython().run_line_magic('matplotlib', 'inline')


# In[2]:


cat4 = cv2.imread('../DATA/CATS_DOGS/train/CAT/4.jpg')
cat4 = cv2.cvtColor(cat4,cv2.COLOR_BGR2RGB)


# In[3]:


type(cat4)


# In[43]:


cat4


# In[4]:


cat4.shape


# In[5]:


plt.imshow(cat4)


# In[6]:


dog2 = cv2.imread('../DATA/CATS_DOGS/train/Dog/2.jpg')
dog2 = cv2.cvtColor(dog2,cv2.COLOR_BGR2RGB)


# In[7]:


dog2.shape


# In[8]:


plt.imshow(dog2)


# ## Preparing the Data for the model
# 
# There is too much data for us to read all at once in memory. We can use some built in functions in Keras to automatically process the data, generate a flow of batches from a directory, and also manipulate the images.
# 
# ### Image Manipulation
# 
# Its usually a good idea to manipulate the images with rotation, resizing, and scaling so the model becomes more robust to different images that our data set doesn't have. We can use the **ImageDataGenerator** to do this automatically for us. Check out the documentation for a full list of all the parameters you can use here!

# In[9]:


from keras.preprocessing.image import ImageDataGenerator


# In[10]:


image_gen = ImageDataGenerator(rotation_range=30, # rotate the image 30 degrees
                               width_shift_range=0.1, # Shift the pic width by a max of 10%
                               height_shift_range=0.1, # Shift the pic height by a max of 10%
                               rescale=1/255, # Rescale the image by normalzing it.
                               shear_range=0.2, # Shear means cutting away part of the image (max 20%)
                               zoom_range=0.2, # Zoom in by 20% max
                               horizontal_flip=True, # Allo horizontal flipping
                               fill_mode='nearest' # Fill in missing pixels with the nearest filled value
                              )


# In[11]:


plt.imshow(image_gen.random_transform(dog2))


# In[12]:


plt.imshow(image_gen.random_transform(dog2))


# In[13]:


plt.imshow(image_gen.random_transform(dog2))


# ### Generating many manipulated images from a directory
# 
# 
# In order to use .flow_from_directory, you must organize the images in sub-directories. This is an absolute requirement, otherwise the method won't work. The directories should only contain images of one class, so one folder per class of images.
# 
# Structure Needed:
# 
# * Image Data Folder
#     * Class 1
#         * 0.jpg
#         * 1.jpg
#         * ...
#     * Class 2
#         * 0.jpg
#         * 1.jpg
#         * ...
#     * ...
#     * Class n

# In[14]:


# image_gen.flow_from_directory('../DATA/CATS_DOGS/train')


# In[15]:


# image_gen.flow_from_directory('../DATA/CATS_DOGS/test')


# ### Resizing Images
# 
# Let's have Keras resize all the images to 150 pixels by 150 pixels once they've been manipulated.

# In[16]:


# width,height,channels
image_shape = (150,150,3)


# # Creating the Model

# In[17]:


from keras.models import Sequential
from keras.layers import Activation, Dropout, Flatten, Dense, Conv2D, MaxPooling2D


# In[18]:


model = Sequential()

model.add(Conv2D(filters=32, kernel_size=(3,3),input_shape=(150,150,3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(filters=64, kernel_size=(3,3),input_shape=(150,150,3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(filters=64, kernel_size=(3,3),input_shape=(150,150,3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))


model.add(Flatten())


model.add(Dense(128))
model.add(Activation('relu'))

# Dropouts help reduce overfitting by randomly turning neurons off during training.
# Here we say randomly turn off 50% of neurons.
model.add(Dropout(0.5))

# Last layer, remember its binary, 0=cat , 1=dog
model.add(Dense(1))
model.add(Activation('sigmoid'))

model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])


# In[19]:


model.summary()


# ### Training the Model

# In[20]:


# image_shape = (150,150,3)

batch_size = 16


# In[21]:


train_image_gen = image_gen.flow_from_directory('../DATA/CATS_DOGS/train',
                                               target_size=image_shape[:2],
                                               batch_size=batch_size,
                                               class_mode='binary')


# In[22]:


test_image_gen = image_gen.flow_from_directory('../DATA/CATS_DOGS/test',
                                               target_size=image_shape[:2],
                                               batch_size=batch_size,
                                               class_mode='binary')


# In[23]:


train_image_gen.class_indices


# In[44]:


test_image_gen


# In[24]:


import warnings
warnings.filterwarnings('ignore')


# In[27]:


results = model.fit_generator(train_image_gen,epochs=2,
                              validation_data=test_image_gen)


# # Evaluating the Model

# In[28]:


results.history['accuracy']


# In[29]:


model.save('cat_dog.h5')


# # Predicting on new images

# In[30]:


import numpy as np
from keras.preprocessing import image


# In[31]:


dog_file = '../DATA/CATS_DOGS/train/Dog/2.jpg'


# In[32]:


dog_img = image.load_img(dog_file, target_size=(150, 150))


# In[33]:


dog_img = image.img_to_array(dog_img)


# In[34]:


dog_img = np.expand_dims(dog_img, axis=0)
dog_img = dog_img/255


# # prediction

# In[35]:


prediction_prob = model.predict(dog_img)
print('Probability that image is a dog is{}'.format(prediction_prob))


# # save and load

# In[37]:


from keras.models import load_model


# In[38]:


new_model = load_model('cat_dog.h5')


# In[40]:


new_model.predict(dog_img)

